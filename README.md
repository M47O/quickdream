
# Quickdream
Quickdream is a full-stack social media app created to explore the capabilities of AI image generation and OpenAI's public API in general. Users are able to enter a prompt and have an image generated based on that prompt. These images are then shared on the Quickdream platform, where users can follow each other, like and comment on images, and discover new and interesting prompts to try. 

<p align="center">
<img src="quickdream-demo.gif" alt="Demo of the Quickdream site">
</p>

[![Netlify Status](https://api.netlify.com/api/v1/badges/b3d0599e-49d2-4be3-a0f7-158f16bd0110/deploy-status)](https://app.netlify.com/sites/quickdream/deploys) [![Railway - Online](https://img.shields.io/static/v1?label=Railway&message=Online&color=bef9c6&logo=Railway)](https://quickdream-production.up.railway.app/)


**Link to project:** [Check it out here!](https://quickdream.netlify.app/)

## How To Install/Run:
  **Prerequisites:**
  - Node ~v18 *(v22 not currently supported)* + npm 
    - I recommend using a Node environment manager such as [nvm](https://github.com/nvm-sh/nvm)/[nvm-windows](https://github.com/coreybutler/nvm-windows), [n](https://github.com/tj/n), or [FNM](https://github.com/Schniz/fnm) to install different versions of Node. This makes switching between versions *very* easy.
  - [MongoDB account](https://www.mongodb.com/) and an Atlas database with an accessible connection string
  - [Cloudinary account](https://www.cloudinary.com)
  - [OpenAI account](https://platform.openai.com/docs/overview)
---

  1. Clone the repo down
  2. Execute `npm install` (need to be using Node 18 - not 22) in both the backend and frontend directories
  3. Create a .env file the in backend/config directory.
  4. Add the following secret key-value pairs to the .env file:
     - PORT = 8080 (or any port you'd like to use)
     - CLOUD_NAME = `your Cloudinary project's cloud name, visible in SETTINGS -> API Keys -> top of the page`
     - CLOUD_API_SECRET = `Cloudinary API secret, visible in SETTINGS -> API Keys`
     - CLOUD_API_KEY = `Cloudinary API key, visible in SETTINGS -> API Keys`
     - DB_STRING = `your MongoDB connection string` [(Instructions on how to find this)](https://www.mongodb.com/resources/products/fundamentals/mongodb-connection-string)
     - OPENAI_API_KEY = `your openai api key` [(Can be found here)](https://platform.openai.com/settings/organization/api-keys)
     - JWT_SECRET = `this can be any value you want` [(Quick primer on JWT secret generation)](https://stackoverflow.com/questions/31309759/what-is-secret-key-for-jwt-based-authentication-and-how-to-generate-it)
   5. `cd` into the backend directory and execute `npm run start` to run the server
   6. `cd` into the frontend directory and execute `npm run dev` to run Vite's development server, accessible at `localhost:5173` in the browser

## How It's Made:

**Tech used:** HTML, CSS, JavaScript, React, Vite, MUI, Express, MongoDB, JSON Web Tokens


The front end is created with `React`, `MUI`, and `CSS`. `MUI` was primarily used for form inputs, buttons, and icons.
The back end uses `Express` as the foundation for the server, and `MongoDB` + `Mongoose` for storing the application's data, while
`bcrypt` is used to hash/salt user passwords before being stored in the database. The `OpenAI` API library is used to generate images from a prompt that are then uploaded to `cloudinary` and stored.
After signing up, users are given a default user avatar that is dynamically generated by the `identicon` package based on their username.
The `Passport` library was recently replaced with JSON Web Tokens using the `jsonwebtoken` library to improve the code's readability and maintainability.
## Lessons Learned:
I approached this project with a new methodology in mind. Rather than ideating and designing pages or components, I started the design process by thinking of the features I wanted to include in the project, and designing the application around them. After I had a rough wireframe, I developed in cycles, tweaking a feature's design, developing the feature, tweaking the next feature's design, developing the next feature. 

This feature-first approach has been tremendously helpful in keeping me focused and my ideas grounded. Following this approach, I only create components or new pages when a certain feature warrants them. This is in contrast to my usual practice of building components I think I'll need and then later shoving them into the app somewhere just so they don't go to waste.

This approach also helped create a clear, linear path of development, as it was easy to rank features by their criticality and prioritize building the most critical features first.
